#   26.1 함수의 구분

### _es6 이전_

자스 함수는 다양한 목적으로 사용됐다.

호출 방식에 특별한 제약이 없었다. 동일한 함수라도 호출 방법이 다양했다.

-   일반적인 함수로서
-   (new 연산자와 함께 호출하여 인스턴스를 생성할 수 있는)생성자 함수로서
-   메서드(객체에 바인딩되어 함수)로서

호출이 가능했다. 모든 함수는 callable이면서 constructor다. 

이는 언뜻 보면 편리한 것 같지만 단점이 있다.

단점

-   실수 유발
-   성능 면에서 손해

```tsx
var foo = function () {
  return 1;
};

// 일반적인 함수로서 호출
foo(); // -> 1

// 생성자 함수로서 호출
new foo(); // -> foo {}

// 메서드로서 호출
var obj = { foo: foo };
obj.foo(); // -> 1
```

주의해야 할 점 ⚠️ 메서드도 `callable`이며 `constructor`임. 따라서 → **메서드도 일반 함수로서 호출할 수 있는 것은 물론 생성자 함수로서 호출할 수도 있다.**

```tsx
var obj = {
  x: 10,
  f: function () { return this.x; }
};

// 프로퍼티 f에 바인딩된 함수를 메서드로서 호출
console.log(obj.f()); // 10

// 프로퍼티 f에 바인딩된 함수를 일반 함수로서 호출
var bar = obj.f;
console.log(bar()); // undefined

// 프로퍼티 f에 바인딩된 함수를 생성자 함수로서 호출
console.log(new obj.f()); // f {}
```

메서드를 생성자 함수로 호출하는 경우가 흔치는 않지만 문법상 가능하다는 것은 **메서드가 prototype 프로퍼티를 가지며, 프로토타입 객체도 생성한다는 것을 의미하기 때문에 성능 면에서 문제가 있다.**

_이게 성능면에서 어떻게 문제가 되는거지? 프로토타입 객체가 불필요해서?_

**콜백함수도** constructor이기 때문에 불필요한 프로토타입 객체를 생성한다.

```tsx
// 콜백 함수를 사용하는 고차 함수 map. 콜백 함수도 constructor이며 프로토타입을 생성한다.
[1, 2, 3].map(function (item) {
  return item * 2;
});
```

생성자 함수로 호출하지 않아도 프로토타입 객체를 생성하기 때문에 → 혼란스러우며 실수를 유발할 가능성이 있고 성능에도 좋지 않다.

⬇️

### _es6_

위 문제를 해결하기 위해 es6에선 함수를 사용 목적에 따라 세 가지 종류로 명확히 구분했다.

- es6 함수의 구분
	
	| ES6 함수의 구분 | constructor | prototype | super | arguments |
	|----------------|-------------|------------|--------|-----------|
	| 일반 함수 (normal) | ✅ | ✅ | ❌ | ✅ |
	| 메서드 (method) | ❌ | ❌ | ✅ | ✅ |
	| 화살표 함수 (arrow) | ❌ | ❌ | ❌ | ❌ |

	_오 정리되는 느낌 좋아_

	es6 이전의 함수와 차이

	-   없음 ❌ - 일반 함수 — `constructor`
	-   있음 ⭕️ - es6의 메서드와 화살표 함수 — `non-constructor`

	_클래스도 일반 함수겠지?_

	gemini : 세 가지 함수 종류 중 어느 하나에 속한다고 단정짓기는 어렵습니다.

#   26.2 메서드

### es6 이전

메서드에 대한 명확한 정의가 없었음. 일반적으로 객체에 바인딩된 함수를 말했음.

### es6

메서드에 대한 명확한 정의가 생김. **메서드 축약 표현으로 정의된 함수**만 메서드임

_오 몰랐어 객체에 바인딩된 함수도 메서드라 하는 줄_

```tsx
const obj = {
  x: 1,
  // foo는 메서드이다.
  foo() { return this.x; },
  // bar에 바인딩된 함수는 **메서드가 아닌 일반 함수**이다.
  bar: function() { return this.x; }
};
```

-   es6 메서드는 `non-constructor`다 → 생성자 함수로서 호출할 수 없다.
    
    ```tsx
    new obj.foo(); // -> TypeError: obj.foo is not a constructor
    new obj.bar(); // -> bar {}  
    ```
    
    _비교 예시 좋다_
    
-   es6 메서드는 인스턴스를 생성할 수 없으므로 → `prototype` 프로퍼티가 없고 프로토타입 객체도 생성하지 않는다. (단점 해결)
    
    ```tsx
    // obj.foo는 constructor가 아닌 ES6 메서드이므로 prototype 프로퍼티가 없다.
    obj.foo.hasOwnProperty('prototype'); // -> false
    
    // obj.bar는 constructor인 일반 함수이므로 prototype 프로퍼티가 있다.
    obj.bar.hasOwnProperty('prototype'); // -> true
    ```
    
-   es6 메서드는 `[[HomeObject]]`를 갖는다.
    
    -   자신을 바인딩한 객체를 가리킨다
    -   내부 슬롯
-   es6 메서드는 super 키워드를 사용할 수 있다.
    
    super 참조는 [[HomeObject]]를 사용해서 수퍼클래스의 메서드를 참조하는데, es6메서드는 [[HomeObject]]를 가져서.
    
	🆚
-   es6 메서드가 아닌 함수는 super 키워드를 사용할 수 없다. ← es6 메서드가 아닌 함수는 [[HomeObject]]를 가지지 않기 때문.
    

**es6 메서드는**

-   **의미적으로 맞지 않는 기능(constructor)을 제거하고**
-   **본연의 기능(super)을 추가했다**

**따라서 메서드를 정의할 때 es6 이전의 방식(프로퍼티 값으로 익명 함수 표현식 할당)은 사용하지 않는 것이 좋다.**

cf) 표준 빌트인 객체가 제공하는 프로토타입 메서드와 정적 메서드는 모두 `non-constructor`다

```tsx
String.prototype.toUpperCase.prototype; // -> undefined
Array.prototype.map.prototype; // -> undefined
```

_구체적인 설명 죠습니다_
