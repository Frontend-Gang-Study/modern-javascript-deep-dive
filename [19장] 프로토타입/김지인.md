자스는

-   명령형, **함수형**, 프로토타입 기반 **객체지향 프로그래밍**을 지원하는 멀티 패러다임 프로그래밍 언어다.
-   클래스 기반 객체지향 프로그래밍 언어(C, Java)보다 효율적이며 더 강력한 객체지향 프로그래밍 능력을 갖는 프로토타입 기반의 객체지향 프로그래밍 언어다

###   클래스

-   es6에서 도입 but, es6의 클래스가 기존의 프로토타입 기반 객체지향 모델을 폐지하고 새로운 객체지향 모델을 제공하는 건 아니다
    
-   클래스도 함수다.
    
-   클래스 vs 생성자 함수
    
    공통점 : 모두 프로토타입 기반의 인스턴스를 생성
    
    차이점 : 정확히 동일하게 동작하지는 않는다.
    
    -   생성자 함수보다 엄격
    -   생성자 함수에서는 제공하지 않는 기능도 제공

자스는 객체 기반의 프로그래밍 언어이며 **자스를 이루고 있는 거의 모든 것이 객체다. 원시 타입의 값을 제외한 나머지 값들(함수, 배열, 정규 표현식 등)은 모두 객체다**

#   19.1 객체지향 프로그래밍

여러 개의 독립적 단위, 즉 객체의 집합으로 프로그램을 표현하려는 프로그래밍 패러다임

실세계의 실체(사물이나 개념)를 인식하는 철학적 사고를 프로그래밍에 접목하려는 시도에서 시작한다. 실체는 특징이나 성질을 나타내는 속성을 가지고 있고, 이를 통해 실체를 인식하거나 구별할 수 있다.

예) 사람은 이름, 나이 등 다양한 속성을 갖는다. 이때 “이름이 아무개이고 나이는 33세인 사람”과 같이 속성을 구체적으로 표현하면 특정한 사람을 다른 사람과 구별해서 인식할 수 있다

이런 방식을 프로그래밍에 접목시켜보자. 우리가 구현하려는 프로그램에선 사람의 이름과 주소라는 속성만 관심있다 해보자.

```jsx
const person = {
	name : "kim",
	address : "seoul"
};
```

프로그래머는 이름과 주소 속성으로 표현된 객체인 person을 다른 객체와 구별해서 인식할 수 있다. 이처럼 속성을 통해 여러 개의 값을 하나의 단위로 구성한 복합적인 자료구조를 객체라 한다.

**객체지향 프로그래밍은 프로퍼티와 메서드를 하나의 논리적인 단위로 묶어 생각한다.** 따라서 객체는 상태 데이터와 동작을 하나의 논리적인 단위로 묶은 복합적인 자료구자라고 할 수 있다. 이때 객체의 상태 데이터를 프로퍼티, 동작을 메서드라 부른다.

각 객체는 고유의 기능을 갖는 독립적인 부품으로 볼 수 있지만 자신의 고유한 기능을 수행하면서 다른 객체와 관계성을 가질 수 있다. 다른 객체와 메시지를 주고 받거나 데이터를 처리할 수도 있다. 또는 **다른 객체의 프로퍼티나 메서드를 상속받아 사용하기도 한다.**

#   19.2 상속과 프로토타입

**자스는 프로토타입을 기반으로 상속을 구현**해서→ 불필요한 중복을 제거한다. 중복을 제거하는 방법은 기존의 코드를 적극적으로 재사용하는 것이다. 코드 재사용은 개발 비용을 현저히 줄일 수 있는 잠재력이 있으므로 매우 중요하다.

```jsx
const circle = {
  radius: 5, // 반지름

  // 원의 지름: 2r
  getDiameter() {
    return 2 * this.radius;
  },

  // 원의 둘레: 2πr
  getPerimeter() {
    return 2 * Math.PI * this.radius;
  },

  // 원의 넓이: πrr
  getArea() {
    return Math.PI * this.radius ** 2;
  }
};

console.log(circle);
// {radius: 5, getDiameter: ƒ, getPerimeter: ƒ, getArea: ƒ}

console.log(circle.getDiameter());  // 10
console.log(circle.getPerimeter()); // 31.41592653589793
console.log(circle.getArea());      // 78.53981633974483
```

위 예제의 생성자 함수는 문제가 있다.

Circle 생성자 함수가 생성하는 모든 객체

-   radius 프로퍼티
    
    radius 프로퍼티 값은 일반적으로 인스턴스마다 다르다.
    
-   getArea 메서드
    
    하지만 getArea 메서드는 **모든 인스턴스가 동일한 내용의 메서드를 사용하므로 단 하나만 생성해서 모든 인스턴스가 공유해서 사용하는게 바람직**하다. 그런데 Circle 생성자 함수는 인스턴스를 생성할 때마다 getArea 메서드를 중복 생성(퍼포먼스에 악영향)하고 모든 인스턴스가 중복 소유(메모리를 불필요하게 낭비)한다. 10개의 인스턴스를 생성하면 내용이 동일한 메서드도 10개 생성된다.
    

를 갖는다.

상속을 통해 불필요한 중복을 제거해보자. **자스는 프로토타입을 기반으로 상속을 구현**한다.

```jsx
function Circle(rad) {
	this.rad = rad;
}
// 생성자 함수
Circle.prototype.getDiameter = function () {
	return this.rad * 2;
}

const circle1 = new Circle(3);
const circle2 = new Circle(7);
//인스턴스 생성
console.log(circle1.getDiameter === circle2.getDiameter);

console.log(circle1.getDiameter());
console.log(circle2.getDiameter());
/*
true
6
14
*/
```

Circle 생성자 함수가 생성한 모든 인스턴스는 자신의 프로토타입인 `Circle.prototype`의 모든 프로퍼티와 메서드를 상속받는다.

`getDiameter` 메서드는 단 하나만 생성되어 프로토타입인 `Circle.prototype`의 메서드로 할당돼있다. 따라서→ Circle 생성자 함수가 생성하는 모든 인스턴스는 `getDiameter` 메서드를 상속받아 사용할 수 있다. 즉, 자신의 상태를 나타내는 rad 프로퍼티만 개별적으로 소유하고 **내용이 동일한 메서드는 상속을 통해 공유해서 사용**하는 것.

**상속은 코드의 재사용이란 관점에서 매우 유용하다.** 생성자 함수가 생성할 모든 인스턴스가 공통적으로 사용할 프로퍼티나 메서드를 프로토타입에 미리 구현해두면 이 인스턴스는 별도의 구현없이 프로토타입의 프로퍼티를 공유해서 사용할 수 있다.

*19장 재밌는데..?
의외로 후루룩 읽혔어
폭풍전야가 아닐까…*
