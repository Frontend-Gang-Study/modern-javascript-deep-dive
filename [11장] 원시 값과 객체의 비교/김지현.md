## Intro

- 자바스크립트가 제공하는 7가지 데이터 타입(`number`, `string`, `boolean`, `null`, `undefined`, `symbol`, `object`)은 크게 **원시 타입**과 **객체 타입**으로 구분할 수 있다.

- **원시 타입**
  - 원시 타입의 값은 변경 불가능한 값
  - 원시 값을 변수에 할당 시, 변수(확보된 메모리 공간)에는 실제 값이 저장
- **객체 타입**

  - 객체(참조) 타입의 값은 변경 가능한 값
  - 객체를 변수에 할당 시, 변수(확보된 메모리 공간)에는 참조 값이 저장

- `pass by value`: ex. 원시 값을 갖는 변수를 다른 변수에 할당 (원시 값 자체가 복사)
- `pass by reference`: ex. 객체를 가리키는 변수를 다른 변수에 할당 (참조 값이 복사)

## 11.1 원시 값

### 11.1.1 변경 불가능한 값

> **변경 불가능한 값** == **원시 타입의 값**
>
> - 변수 != 값
> - 원시 타입의 값 == 변수에 할당된 원시 값
> - 변수는 언제든지 재할당을 통해 변수 값을 변경할 수 있다!

- 값을 변경할 수 없다는 말의 의미는, 변수가 아닌 변수에 저장되는 데이터(값)에 대한 말이다.
- 일반적으로 우리가 변수에 값을 할당하고 새로운 값으로 다시 할당할 때, **변경하는 것처럼 보여도 사실은 새 값, 새로운 메모리 공간을 할당받아 만드는 것**이다.
- C, C++에서의 메모리 구조 상, 변수를 선언함과 동시에 메모리에 해당 변수의 공간(크기에 따라 맞춰진)이 생성되고, 값을 새로 할당하면 해당 메모리 위치에 값이 변경되는 형태로 이루어진다.
- 하지만, JavaScript에서는 변수를 선언하면 하나의 위치에 값(또는 undefined)과 함께 공간이 할당되며, 새로 할당 시 해당 위치가 아닌 **또 다른 새로운 공간에 새로운 메모리를 할당받고, 그 공간을 해당 변수가 가리키도록** 된다.

### 11.1.2 문자열과 불변성

> **자바스크립트 원시 값의 불변성이란?**
>
> - 자바스크립트의 원시 값은 생성된 이후로 그 자체를 바꿀 수 없다.
> - 예를들어, 문자열은 한 번 만들어지면 글자를 **직접 바꿀 수 없고**, 숫자도 그 값을 메모리 상에서 직접 수정하지 않는다.

> **유사 배열 객체**
> : 유사 배열 객체란 마치 배열처럼 인덱스로 프로퍼티 값에 접근할 수 있고 length 프로퍼티를 갖는 객체를 말한다. 문자열은 마치 배열처럼 인덱스를 통해 각 문자에 접근할 수 있으며, length 프로퍼티를 갖기 때문에 유사 배열 객체이고 for 문으로 순회할 수도 있다.

```javascript
var str = "jihyun";

// 문자열은 유사 배열 객체이므로 인덱스를 사용해 각 문자에 접근할 수 있으며, length 프로퍼티를 사용할 수 있다.
console.log(str[0]); // s
console.log(str.length); // 6

// 인덱스를 사용해 각 문자에 접근은 가능하나, 원시 값이므로 변경할 수 없다!!!!
str[0] = "J"; // 반영되지 않음 (원시 값은 읽기 전용 값이므로)
console.log(str); // jihyun

// 아예 변수에 값을 새로이 할당하는 것은 가능하다
str = "Jihyun"; // 가능
console.log(str); // Jihyun
```

### 11.1.3 값에 의한 전달

- **pass by value**: 원시 값을 갖는 변수에 대해 다른 변수에 해당 변수를 할당 시, 변수의 **원시 값** 자체를 복사하여 전달된다.

```javascript
var score = 80;

// 원시 값을 갖는 score에 대해 copy라는 변수에 할당 시, 값이 복사되어 할당된다
var copy = score;

console.log(score, copy); // 80 80
console.log(score === copy); // true

// score과 copy는 각각 다른 메모리 공간에 할당된 변수이므로 한 변수의 값을 변경한다고 해서 다른 값에 영향을 주지 않는다.
score = 100;
console.log(score === copy); // false
```

- **엄격히 표현하면, 변수에는 값이 전달되는 것이 아니라 공간을 할당받은 메모리 주소가 전달된다. 이는 변수와 같은 식별자는 값이 아니라 메모리 주소를 기억하고 있기 때문이다.**

- **식별자는 메모리 주소에 붙인 이름**이라고 할 수 있다.

## 11.2 객체

객체는 프로퍼티의 개수가 정해져 있지 않으며, 동적으로 추가하고 삭제할 수 있다. 또한 프로퍼티의 값에도 제약이 없다. 따라서 객체는 원시 값과 같이 확보해야 할 메모리 공간의 크기를 사전에 정해둘 수 없다.

- 객체는 복합적인 자료구조로, 객체를 관리하는 방식이 원시 값과는 다른 방식으로 동작하도록 설계되어 있다.
  - 객체는 경우에 따라 크기가 매우 다라지며, 객체를 생성하고 프로퍼티에 접근하는 것도 원시 값과 비교할 때 비용이 많이 들기 때문이다.

### 11.2.1 변경 가능한 값

**객체(참조) 타입의 값, 즉 객체는 변경 가능한 값**이다.

- 원시 값을 할당한 변수는 원시 값 자체를 값으로 가지며 호출 시, 해당 값이 호출된다.
- 객체를 할당한 변수를 호출 시, 해당 변수가 기억하는 메모리 주소를 통해 메모리 공간에 접근하며, 참조 값으로 접근할 수 있다. 이때, **참조 값은 메모리 공간의 주소**, 그 자체이다.

**얕은 복사와 깊은 복사**
: 객체를 프로퍼티 값으로 같응 객체의 경우, 얕은 복사는 한 단계까지만 복사하는 것을 말하고, 깊은 복사는 객체에 중첩되어 있는 개체까지 모두 복사하는 것을 말한다.

- 얕은 복사와 깊은 복사로 생성된 객체는 원본과는 다른 객체이다.

### 11.2.2 참조에 의한 전달

객체를 가리키는 변수를 다른 변수에 할당 시, 원본의 참조 값이 복사되어 전달된다. 이를 참조에 의한 전달이라 한다.
이때, 참조 값이란 메모리 주소 자체를 의미하며, 두 변수가 결국에 하나의 객체를 가리키게 되는 즉, **두개의 식별자가 하나의 객체를 공유**하는 상황이라고 볼 수 있다.

결국 값에 의한 전달과 참조에 의한 전달은 **식별자가 기억하는 메모리 공간에 저장되어 있는 값을 복사해서 전달한다**는 면에서 동일하지만, 해당 값이 원시 값이냐 참조 값이냐의 차이가 있을 뿐이다.
