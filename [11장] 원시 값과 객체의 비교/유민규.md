## 11.1 원시 값

### 11.1.1 변경 불가능한 값

> JS에서 제공하는 7가가 타입 : 숫자. 문자열, 불리언
> null, undefined, 심벌, 객체 타입

> 각 타입을 원시타입과 객체타입으로 나눌수 있음

- 원시 타입 : 변경 불기능한 값,
  - 변수에 할당 시 메모리에 **실제 값**이 저장
  - 원시 값의 가진 변수를 다른 변수에 할당 -> 원시값 복사 (값에 의한 전달)
- 객체 타입 : 변경 가능한 값

  - 변수에 할당 시 메모리에 **참조 값**이 저장 ->
  - 객체 값의 가진 변수를 다른 변수에 할당 -> 참조값 복사 (참조에 의한 전달)

- 원시값 == 변경 불가능한 값 == 읽기 전용

> **변수** : 메모리 공간을 식별하기 위한 불린 값 \
> **값** : 변수에 저장된 데이터 \
> 즉, 변경 불가능한 것은 변수가 아니라 **값**

- 변수는 변경 가능 , 값은 변경 불가능
- 상수 : 재할당이 금지된 변수

> 상수와 변경 불가능한 값은 동일시하면 안됨!

```js
// const 키워드를 사용해 선언한 변수는 재할당이 금지된다. (상수)
const o = {};
// const 키워드를 시용해 선언한 변수에 할당한 원시 값(싱수)은 변경불가능
// 하지만 const 키워드틀 사용해 선언한 변수에 할당한 객체는 변경가능
o.a = 1; // o.a는 o라는 상수에 a라는 변수를 설정
console.1og(o); // {a: 1}
```

- 원시값을 할당한 변수는 재할당 이외에 변수 값을 변경 불가능
  - 이런 특징을 **불변성** 이라고 함

### 11.1.2 문자열과 불변성

- 원시 값을 저장하려면 먼저 확보애햐 하는 메모리 공간의 크기를 결정

- 원시 타입별로 크키는 미리 정해져 있음

- 문자열 : 0개 이상의 문자로 이뤄진 집합

  - 1개 문자는 2바이트 메모리 공간
  - 숫자는 1, 1000000 둘다 8바이트 필요 -> 숫자는 8바이트씩 저장

- C는 Char 타입만 존재 (string없음)
- JS는 개발자 편의를 위해 문자열 타입 제공

```js
var Str = "HeUo";
str = "world";
```

- 위 코드에서 Str은 Hello가 저장된 공간의 주소를 가리킴
- 그 다음 'world' 가 저장된 공간의 주소를 가리킴

  - 즉. 메모리 상엔, Hello와 world 둘다 존재

- 문자열은 **유사 객체 배열**
  > 유사 배열 객체란 마치 배열처렴 인덱스로 프로퍼티값에 접근할 수 있고 length 프로퍼티를 갖는 객체\
  > 기존 값(원시 값)은 변경 불가능

```JS
var str= 'string' ;
// 문자열은 유사 배열, 인덱스를 시용해 각 문지에 접근 가능
console.log(str[0]); // s

// 원시 값인 문자열이 객체처럼 동작한다.
console.log(str.length); // 6
console.log(str.toUppercase()); // STRING

// 값 자체는 원시값이라 값 자체를 변경 불가능
str[0] = 'S' ;
console.log(str); // string
```

### 값에 의한 전달

```JS
var score = 80;
var copy = score;

console.log(score); // 80
console.log(copy); // 80
score = 100;

console.log(score); // 100
console.log(copy); // 80
```

- 위 코드에서 copy가 80이 나오는 이유 -> 값에 의한 복사

  - score가 가리키는 곳 -> 80을 담은 메모리 공간 A
  - copy가 가리키는 곳 -> 80을 담은 메모리 공간 B
  - 즉, copy = score은 80이라는 값을 복사하고 새로운 메모리 공간을 만들어 할당 == **값에 의한 복사**

- 하지만 특정 기간동한 score와 copy이 값은 값 A를 가리키다가 나중에 score은 A, copy는 B를 가리킬수 있음

  - python이 이 방식

- 값에 의한 전달 == 공유에 의한 전달
  - 정확하게는 메모리 주소가 전달됨
  - 변수와 같은 식별자는 값이 아니라 메모리 주소를 기억

> 식별자 : 변수와 같이 값을 구별하여 식별\
> 예를 들어 메모리 공간에 저장되어 있는 어떤 값을 구별하여 식별 (==변수)

- 값에 의한 전달 == 실제로는 값이 아니라 메모리 주소를 전달
  - 변수에 원시값을 갖는 변수를 할당하면 두 변수의 원시 값은 **서로 다른 메모리 공간**에 저장된다

## 객체

- 프로퍼티 개수가 정해져 있지 않음
- 프로퍼티 값에 제한이 없음

  - 즉, 메모리 공간의 크기를 사전에 정의 불가능

- JS는 프로퍼티 키를 인덱스로 하는 해시 테이블로 저장을 한다
  - 자바스크립트 엔진은 해시 테이블보다 더 효율적인 방식으로 객체를 구현하여 성능을 향상

> 히든 클래스 (Hidden Class)\
> V8 자바스크립트 엔진은 동적 탐색 대신 히든 클래스를 사용하여 객체의 프로퍼티에 빠르게 접근\
> 히든 클래스는 클래스 기반 언어의 고정된 객체 레이아웃과 유사하게 동작하여 성능을 최적화합니다.\
> 이를 통해 자바스크립트 객체도 클래스 기반 언어의 객체와 비슷한 속도로 프로퍼티에 접근할 수 있습니다.

### 11.2.1 변경 가능한 값

- 객체 : 변경 가능한 값

```js
// 할당이 이뤄지는 시점에 객체 리터럴이 해석되고, 그 결과 객체가 생성된다.
var person = {
  name: "Lee",
};

// person 변수에 저징되어 있는 침초 값으로 실제 객체에 접근한다
console.log(person); // {name; "Lee"}
```

- 일반적으로 객체를 "변수는 객체를 참조하고 있다." OR "변수는 객체를 가리키고 있다" 라고 부른다

- 원시값은 변경 불가능, 하지만 객체는 변경 가능한 값이다
- 즉, 객체를 할당한 변수는 재할당 없이 객체를 직접 변경 가능
  - 즉, 재할당 없이 프로퍼티를 동적으로 추가, 값 갱신, 프로퍼티 삭제가 가능

```js
var person = {
  name: "lee",
};

// 프로퍼티 값 갱신
person.name = "Kim";

// 프로퍼티 동적 생성
person.address = "seoul";

consoIe.log(person); // {name: ''Kim", address: "Seoul''}
```

- 객체는 변경 가능한 값 -> 메모리에 저장된 객체를 직접 수정 가능
- 수정할 때, 객체를 할당한 변수에 재할당을 안함 -> 객체를 할당한 변수의 참조값은 변경되지 않음
- 예를 들어 객체 내부 프로퍼티를 수정한다 해도 객체를 할당한 변수 그 자체의 참조값은 변경 안함,
  - person이 가리키는 메모리는 변경 안함

</br>

---

</br>

- 객체를 변경할 때마다 원시값처럼 이전 값을 복사 및 생성한다면 신뢰성이 확보
- 하지만 객체는 크기가 일정하지 않음 -> 복사에 생성하는 비용이 많음

  > 그래서 객체는 변경 가능한 값으로 설계됨

- 하지만 객체가 변경 가능해 지므로 여러 개의 식별자가 하나의 객체를 공유할수 있다는 **단점**이 생김

### 얕은 복사, 깊은 복사

- 얕은 복사는 한 단계까지만 복사
- 깊은 복사는 객체에 중첩되어 있는 객체까지 모두 복사

- **얕은 복사**와 **깊은 복사**로 생성된 객체는 원본과는 다른 객체

```js

const o = { x: { y: 1 } };

// 얕은 복사
const cl = { ...o };
console.log(cl === o);//false
console.log(cl.x === o.x); // true

// lodash의 cloneDeep을 사용한 깊은 복사
// "npm install lodash의''로 lodash의 설치한 후, Node.js 환경에서 실행
const =require( 'lodash' );

// 깊은 복사
const C2 = .cloneDeep(o);
console.log(C2 === o); // false
console.log(C2.x === o.x); // false

const v = 1;

// ''깊은 복사"리고 부르기도 한다,
const cl = v;
console.log(cl === V); // true

const o = { x: 1 };
// "얕은 복사"라고 부르기도 한다.
const c2 = o;
console.log(c2 === o); // true
```

### 11.2.2 참조에 의한 전달

```js
var person = {
  name: "Lee",
};

// 참조 값을 복사(앝은 복사)
var copy = person;
```

- 위 코드대로면 person, copy의 메모리 주소는 다름
  - 하지만 동일한 참조 값(객체)를 가짐, 하나의 객체를 공유
  - 참조에 의한 전달

```js
var person = {
  name: "Lee",
};
// 참조 값을 복사(얕은 목사). copy와 person은 동일한 참조 값을 갖는다
var copy = person;

// copy와 person은 동일한 객처듣 참조한다.
console.log(copy === person); // true

// copy를 통해 객처돝 변경한다
copy.name = "kim";

// person을 통해 객처틈 변경한다
person.address = "Seoul";

// copy와 person은 동일한 객체를 가리킨다.
// 따라서 어느 한쪽에서 객처듣 변경하면 서로 영향을 주고받는다.
console.log(person);
// {nalne: "Kim'' , address: ''seoul"}

console.log(copy);
//{name: "Kim'', address: "Seoul"}
```

- 위 코드를 보면 참조를 위한 전달과 값에 의한 전달은 같은 결과가 나오는 것을 알 수 있다
  - 참조에 의한 전달 -> 변수의 저장된 값이 참조 값
  - 값에 의한 전달 -> 변수의 저장된 값이 값
- 객체에선 실제 똑같은 결과로 보여지므로 값에 의한 전달만 존재한다고 말함
  - 그래서 JS에선 '공유에 의한 전달' 이라고 표현한다

> JS에선 포인터라는 개념이 없어서 다른 언어에서의 call by value, call by reference랑 정확히 일치하지 않는다

```js
var person1 = {
  name: "Lee",
};

var person2 = {
  name: "Lee",
};

console.log(person1 === person2); // 1번
console.log(person1.name === person2.name); // 2번
```

> === 일치 비교 연산자

- 변수의 저장되어 있는 값을 타입변환하지 않고 그대로 비교

  - 1, '1' 을 비교할때 타입 변환한하고 숫자와 문자열을 그대로 비교함

- 1번은 객체는 같지만 다른 메모리에 저장된 별개의 객체이므로 false
- 2은 객체 내부의 원시값 'Lee'가 반환되므로 true이다.
